/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.exadel.etoolbox.linkinspector.core.services.data.impl;

import com.adobe.granite.ui.components.ds.ValueMapResource;
import com.exadel.etoolbox.linkinspector.core.models.Link;
import com.exadel.etoolbox.linkinspector.core.models.LinkStatus;
import com.exadel.etoolbox.linkinspector.core.models.ui.GridViewItem;
import com.exadel.etoolbox.linkinspector.core.services.data.DataFeedService;
import com.exadel.etoolbox.linkinspector.core.services.data.GridResourcesGenerator;
import com.exadel.etoolbox.linkinspector.core.services.data.models.GridResource;
import com.exadel.etoolbox.linkinspector.core.services.helpers.RepositoryHelper;
import com.exadel.etoolbox.linkinspector.core.services.util.CsvUtil;
import com.exadel.etoolbox.linkinspector.core.services.util.LinkInspectorResourceUtil;
import org.apache.commons.collections4.ListUtils;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.StopWatch;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ValueMap;
import org.apache.sling.api.wrappers.ValueMapDecorator;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Implements {@link DataFeedService} interface to provide an OSGi service which is responsible for managing the data
 * feed based on the set of resources generated by ${@link GridResourcesGenerator}
 */
@Component(service = DataFeedService.class)
public class DataFeedServiceImpl implements DataFeedService {
    private static final Logger LOG = LoggerFactory.getLogger(DataFeedServiceImpl.class);


    @Reference
    private RepositoryHelper repositoryHelper;

    @Reference
    private GridResourcesGenerator gridResourcesGenerator;

    /**
     * The location of the generated Csv report in the repository
     */
    public static final String CSV_REPORT_NODE_PATH = "/content/etoolbox-link-inspector/data/content";

    /**
     * The sling resource type of grid row items
     */
    private static final String GRID_RESOURCE_TYPE = "etoolbox-link-inspector/components/gridConfig";
    /**
     * The number of items displayed in the grid is limited
     */
    private static final int UI_ITEMS_LIMIT = 500;

    /**
     * {@inheritDoc}
     */
    @Override
    public void generateDataFeed() {
        LOG.info("Start link inspector data feed generation");
        try (ResourceResolver resourceResolver = repositoryHelper.getServiceResourceResolver()) {
            if (resourceResolver == null) {
                LOG.warn("ResourceResolver is null, data feed generation is stopped");
                return;
            }
            Optional.of(gridResourcesGenerator.generateGridResources(GRID_RESOURCE_TYPE, resourceResolver))
                    .ifPresent(gridResources -> {
                        generateCsvReport(gridResources, resourceResolver);
                        removePendingNode(resourceResolver);
                    });
            LOG.info("Link inspector data feed generation is completed");
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<Resource> dataFeedToResources(int page) {
        LOG.debug("Start data feed to resources conversion");
        try (ResourceResolver serviceResourceResolver = repositoryHelper.getServiceResourceResolver()) {
            if (serviceResourceResolver == null) {
                LOG.warn("ResourceResolver is null, data feed to resources conversion is stopped");
                return Collections.emptyList();
            }
            List<Resource> resources = toSlingResourcesStream(dataFeedToGridResources(serviceResourceResolver, page),
                    repositoryHelper.getThreadResourceResolver())
                    .collect(Collectors.toList());
            LOG.info("EToolbox Link Inspector - the number of items shown is {}", resources.size());
            return resources;
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<List<GridResource>> dataFeedToGridResources() {
        try (ResourceResolver serviceResourceResolver = repositoryHelper.getServiceResourceResolver()) {
            if (serviceResourceResolver == null) {
                LOG.warn("ResourceResolver is null, data feed to grid resources conversion is stopped");
                return Collections.emptyList();
            }
            return dataFeedToGridResources(serviceResourceResolver);
        }
    }

    @Override
    public void modifyCsvRecord(ResourceResolver resourceResolver, String filePath, Consumer<GridResource> modifyConsumer) {
        Optional<InputStream> inputStream = Optional
                .ofNullable(resourceResolver.getResource(filePath))
                .map(resource -> resource.adaptTo(InputStream.class));
        if (inputStream.isPresent()) {

            List<GridViewItem> recordDtoList = CsvUtil.readCsvItems(inputStream.get(), CsvUtil.CSV_COLUMNS).stream()
                    .map(this::parseGridResourceFromCsv)
                    .peek(modifyConsumer)
                    .map(gridResource -> toSlingResource(gridResource, resourceResolver))
                    .map(resource -> resource.adaptTo(GridViewItem.class))
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());

            byte[] csvContentBytes = CsvUtil.itemsToCsvByteArray(recordDtoList, this::printViewItemToCsv, null);
            LinkInspectorResourceUtil.removeResource(filePath, resourceResolver);
            LinkInspectorResourceUtil.saveFileToJCR(filePath, csvContentBytes,
                    CsvUtil.CSV_MIME_TYPE, resourceResolver);
        }
    }

    private List<List<GridResource>> dataFeedToGridResources(ResourceResolver resourceResolver) {
        List<List<GridResource>> gridResources = new ArrayList<>();
        Resource resource = resourceResolver.getResource(CSV_REPORT_NODE_PATH);
        if (resource == null) {
            LOG.error("Resource " + CSV_REPORT_NODE_PATH + " doesn't exist.");
            return gridResources;
        }
        Long size = resource.getValueMap().get(CsvUtil.REPORTS_SIZE_PROPERTY_NAME, Long.class);
        if (size != null) {
            for (int i = 1; i <= size; i++) {
                gridResources.add(dataFeedToGridResources(resourceResolver, i));
            }
        }
        return gridResources;
    }


    private List<GridResource> dataFeedToGridResources(ResourceResolver resourceResolver, int page) {
        Optional<InputStream> inputStream = Optional
                .ofNullable(resourceResolver.getResource(LinkInspectorResourceUtil.buildResourcePathFromPageNumber(CSV_REPORT_NODE_PATH, page)))
                .map(resource -> resource.adaptTo(InputStream.class));

        return inputStream.map(stream -> CsvUtil.readCsvItems(stream, CsvUtil.CSV_COLUMNS)
                .stream().map(this::parseGridResourceFromCsv)
                .collect(Collectors.toList())).orElse(Collections.emptyList());
    }

    private void removePendingNode(ResourceResolver resourceResolver) {
        LinkInspectorResourceUtil.removeResource(DataFeedService.PENDING_GENERATION_NODE, resourceResolver);
    }

    private Stream<Resource> toSlingResourcesStream(Collection<GridResource> gridResources, ResourceResolver resourceResolver) {
        return gridResources.stream()
                .map(gridResource -> toSlingResource(gridResource, resourceResolver));
    }

    private Resource toSlingResource(GridResource gridResource, ResourceResolver resourceResolver) {
        ValueMap valueMap = new ValueMapDecorator(new HashMap<>());
        valueMap.put(GridResource.PN_LINK, gridResource.getHref());
        valueMap.put(GridResource.PN_LINK_TYPE, gridResource.getType());
        valueMap.put(GridResource.PN_LINK_STATUS_CODE, gridResource.getStatusCode());
        valueMap.put(GridResource.PN_LINK_STATUS_MESSAGE, gridResource.getStatusMessage());
        valueMap.put(GridResource.PN_RESOURCE_PATH, gridResource.getResourcePath());
        valueMap.put(GridResource.PN_PROPERTY_NAME, gridResource.getPropertyName());
        return new ValueMapResource(resourceResolver, gridResource.getResourcePath(), gridResource.getResourceType(), valueMap);
    }

    private void generateCsvReport(Collection<GridResource> gridResources, ResourceResolver resourceResolver) {
        StopWatch stopWatch = StopWatch.createStarted();
        LOG.debug("Start CSV report generation");

        List<GridViewItem> gridViewItems = toSlingResourcesStream(gridResources, resourceResolver)
                .map(resource -> resource.adaptTo(GridViewItem.class))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        List<List<GridViewItem>> partitionGridViewItems = ListUtils.partition(gridViewItems, UI_ITEMS_LIMIT);
        LinkInspectorResourceUtil.removeResource(CSV_REPORT_NODE_PATH, resourceResolver);
        LinkInspectorResourceUtil.createNode(CSV_REPORT_NODE_PATH, resourceResolver);
        LinkInspectorResourceUtil
                .addParamToNode(CSV_REPORT_NODE_PATH, resourceResolver, CsvUtil.REPORTS_SIZE_PROPERTY_NAME, (long) partitionGridViewItems.size());

        for (int i = 0; i < partitionGridViewItems.size(); i++) {
            byte[] csvContentBytes = CsvUtil.itemsToCsvByteArray(partitionGridViewItems.get(i), this::printViewItemToCsv, null);
            LinkInspectorResourceUtil.saveFileToJCR(LinkInspectorResourceUtil.buildResourcePathFromPageNumber(CSV_REPORT_NODE_PATH, i + 1), csvContentBytes,
                    CsvUtil.CSV_MIME_TYPE, resourceResolver);
        }

        stopWatch.stop();
        LOG.debug("Generation of CSV report is completed in {} ms", stopWatch.getTime(TimeUnit.MILLISECONDS));
    }

    private void printViewItemToCsv(CSVPrinter csvPrinter, GridViewItem viewItem) {
        try {
            csvPrinter.printRecord(
                    CsvUtil.wrapIfContainsSemicolon(viewItem.getLink()),
                    viewItem.getLinkType(),
                    viewItem.getLinkStatusCode(),
                    CsvUtil.wrapIfContainsSemicolon(viewItem.getLinkStatusMessage()),
                    CsvUtil.wrapIfContainsSemicolon(viewItem.getPageTitle()),
                    viewItem.getPagePath(),
                    CsvUtil.wrapIfContainsSemicolon(viewItem.getComponentName()),
                    viewItem.getComponentType(),
                    CsvUtil.buildLocation(viewItem.getPath(), viewItem.getPropertyName())
            );
        } catch (IOException e) {
            LOG.error(String.format("Failed to build CSV for the grid resource %s", viewItem.getLink()), e);
        }
    }

    private GridResource parseGridResourceFromCsv(CSVRecord csvRecord) {
        String code = csvRecord.get(CsvUtil.CSV_COLUMN_CODE);
        String statusMessage = csvRecord.get(CsvUtil.CSV_COLUMN_STATUS_MESSAGE);
        Link link = new Link(csvRecord.get(CsvUtil.CSV_COLUMN_LINK), Link.Type.valueOf(csvRecord.get(CsvUtil.CSV_COLUMN_TYPE).toUpperCase()));
        link.setStatus(new LinkStatus(Integer.parseInt(code), statusMessage));
        return new GridResource(link,
                StringUtils.substringBeforeLast(csvRecord.get(CsvUtil.CSV_COLUMN_PROPERTY_LOCATION), CsvUtil.AT_SIGN),
                StringUtils.substringAfterLast(csvRecord.get(CsvUtil.CSV_COLUMN_PROPERTY_LOCATION), CsvUtil.AT_SIGN),
                GRID_RESOURCE_TYPE);
    }
}